//지뢰찾기와 비슷한 로직 입니다 field배열에 1이있는곳 주변의 칸에 숫자를 증가시키는 코드

void main{
/*
지뢰위치
0 1 0 1
0 0 0 1
1 1 1 0
0 1 1 1
*/
field {{0,1,0,1},
       {0,0,0,1},
       {1,1,1,0},
       {0,1,1,1}};
//1이 있는 곳이 지뢰
mines {{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0}}; 
/*
1) 처음엔 전부 0
2) 지뢰 1의 위치
(0, 1) 첫번째 배열에 2번째 칸

2번째를 포함하여
각(가로 3칸) 각(세로 3칸)

1110
1110
0000
0000

지뢰 2 위치


*/
//각 칸 주변 지뢰개수를 세서 저장할 배열 입니다
//w = 4, h =4 
/*
 출력값이 처음엔 모두 0 이고 그렇지 않으면
 엉망인 값이 나온다

 현실비유
 지뢰 = 사람이 지나감 

 mines 출입 횟수 카운터
 처음엔 아무도 안지나감 -> 0
 한명 지나감 - 1
 또 지나감 - 2
 그래서 배열에 초기화는 중요하다 
*/
 
int w = 4, h = 4;//배열의 가로, 세로
  for(y=0; y<h; y++) {//주변 칸 증가 시키기
    for(x=0; x<w; x++) {  
    if(field[y][x] == 0) continue; //field[y][x] == 1 지뢰인 경우
    //주변 3 x 3 칸을 모두 chke 자기자신을 제외하면 주변 8칸
    
      for(i=y-1; i<=y+1; i++) { //
        for(j=x-1; j<=x+1; j++) {
          if(calculate(w,h,j,i) == 1) {//만약 해당칸이 배열 안에 있으면 1을 리턴
            mines[i][j] += 1;//주변 지뢰수 증가
          }
        }
      }
    }
  }
  for(y=0; y<h; y++){
    for(x=0; x<w; x++)
      printf("%d", mines[y][x]);
      printf("\n");
  }
 
}
 
 
int calculate(w,h,j,i) {//배열 밖으로 나가면 안되니까 체크
//범위 안이면 1, 아니면 0
  if (i >= 0 && i < h && j >= 0 && j < w) return 1;
  return 0;
}